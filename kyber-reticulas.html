<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flujo Kyber: KEM + AES</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Crimson+Pro:wght@300;600&display=swap');
        
        :root {
            --bg-dark: #0a0e27;
            --bg-card: #1a1f3a;
            --accent-cyan: #00f0ff;
            --accent-magenta: #ff00aa;
            --accent-yellow: #ffee00;
            --text-primary: #e8e8f0;
            --text-secondary: #9999bb;
            --lattice-point: #00f0ff;
            --lattice-line: #2a3f5f;
            --noise-color: #ff00aa;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow-x: hidden;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        header {
            text-align: center;
            padding: 3rem 0;
            position: relative;
        }
        
        h1 {
            font-family: 'Space Mono', monospace;
            font-size: clamp(2rem, 5vw, 4rem);
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta), var(--accent-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            letter-spacing: -0.02em;
            animation: fadeInDown 0.8s ease-out;
        }
        
        .subtitle {
            font-size: 1.3rem;
            color: var(--text-secondary);
            font-weight: 300;
            animation: fadeIn 1s ease-out 0.3s both;
        }
        
        .step-container {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 3rem;
            margin: 2rem 0;
            border: 2px solid transparent;
            background-clip: padding-box;
            position: relative;
            overflow: hidden;
            opacity: 0;
            transform: translateY(20px);
            animation: slideUp 0.6s ease-out forwards;
        }
        
        .step-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
        }
        
        .step-container:nth-child(1) { animation-delay: 0.1s; }
        .step-container:nth-child(2) { animation-delay: 0.2s; }
        .step-container:nth-child(3) { animation-delay: 0.3s; }
        .step-container:nth-child(4) { animation-delay: 0.4s; }
        .step-container:nth-child(5) { animation-delay: 0.5s; }
        .step-container:nth-child(6) { animation-delay: 0.6s; }
        .step-container:nth-child(7) { animation-delay: 0.7s; }
        
        .step-number {
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            color: var(--accent-cyan);
            font-weight: 700;
            margin-bottom: 1rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        .step-title {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
        }
        
        .step-text {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            line-height: 1.8;
        }
        
        .highlight {
            color: var(--accent-yellow);
            font-weight: 600;
        }
        
        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem 0;
            border: 1px solid rgba(0, 240, 255, 0.2);
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 10px;
            cursor: crosshair;
            width: 100%;
            max-width: 600px;
            height: auto;
        }
        
        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .footer-controls {
            margin: 3rem 0 1rem;
        }
        
        button {
            font-family: 'Space Mono', monospace;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border: none;
            color: var(--bg-dark);
            padding: 0.8rem 2rem;
            border-radius: 50px;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 240, 255, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .slider-container {
            margin: 1.5rem 0;
        }
        
        .slider-label {
            font-family: 'Space Mono', monospace;
            display: block;
            margin-bottom: 0.5rem;
            color: var(--accent-cyan);
            font-size: 0.9rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--accent-magenta);
            transform: scale(1.2);
        }
        
        .info-box {
            background: rgba(0, 240, 255, 0.1);
            border-left: 4px solid var(--accent-cyan);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 10px;
            font-size: 1.1rem;
        }
        
        .code-block {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            font-family: 'Space Mono', monospace;
            font-size: 0.95rem;
            color: var(--accent-yellow);
            overflow-x: auto;
        }
        
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .interactive-label {
            text-align: center;
            font-family: 'Space Mono', monospace;
            color: var(--accent-yellow);
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .step-container {
                padding: 2rem 1.5rem;
            }
            
            .step-title {
                font-size: 1.5rem;
            }
            
            .step-text {
                font-size: 1rem;
            }

            .canvas-container {
                padding: 1rem;
                margin: 1.5rem 0;
            }

            .controls {
                flex-direction: column;
                gap: 0.75rem;
                align-items: stretch;
            }

            button {
                width: 100%;
                font-size: 0.9rem;
                padding: 0.8rem 1rem;
            }

            .interactive-label {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>FLUJO KYBER: KEM + AES</h1>
            <div class="subtitle">KeyGen, Encaps, Decaps, verificación y cifrado simétrico</div>
        </header>

        <!-- Paso 1: Bob genera claves -->
        <div class="step-container">
            <div class="step-number">Paso 01</div>
            <div class="step-title">Bob genera su par de claves (KeyGen)</div>
            <div class="step-text">
                Bob crea una retícula pública, elige una dirección secreta y añade un poco de ruido.
                Eso produce una <span class="highlight">clave pública</span> (visible para todos) y una
                <span class="highlight">clave privada</span> (solo de Bob).
            </div>
            <div class="code-block">
                A: matriz pública en la retícula<br>
                s: clave privada (vector secreto de Bob)<br>
                e: ruido pequeño<br>
                t = A · s + e<br>
                clave pública = (A, t)
            </div>
            
            <div class="canvas-container">
                <canvas id="lattice5" width="600" height="600"></canvas>
                <div class="controls">
                    <button onclick="generateKeyPair()">Crear clave pública</button>
                    <button onclick="showPrivateKey()">Revelar Clave Privada</button>
                    <button onclick="resetDemo5()">Reiniciar</button>
                </div>
                <div class="interactive-label">Clave pública con ruido vs clave privada (dirección secreta)</div>
            </div>
        </div>

        <!-- Paso 2: Alice encapsula -->
        <div class="step-container">
            <div class="step-number">Paso 02</div>
            <div class="step-title">Alice encapsula usando la clave pública</div>
            <div class="step-text">
                Alice toma la clave pública de Bob y agrega aleatoriedad para producir un
                <span class="highlight">ciphertext</span> y un secreto compartido <span class="highlight">shared_secret_A</span>.
            </div>
            <div class="step-text">
                La aleatoriedad garantiza que cada encapsulación sea distinta aunque use la misma clave pública.
            </div>
            
            <div class="canvas-container">
                <canvas id="lattice2" width="600" height="600"></canvas>
                <div class="controls">
                    <button onclick="createNoise()">Crear ruido</button>
                    <button onclick="runEncapsulation()">Encapsular</button>
                    <button onclick="resetDemo2()">Reiniciar</button>
                </div>
                <div class="interactive-label">La aleatoriedad de Alice crea un ciphertext único</div>
            </div>
            
            <div class="info-box">
                <strong>Clave pública de Bob:</strong> <span id="publicKeyOutput">-</span><br>
                <strong>Ciphertext:</strong> <span id="ciphertextOutput">-</span><br>
                <strong>shared_secret_A:</strong> <span id="secretAOutput">-</span><br>
                <strong>Ruido generado (Alice):</strong> <span id="noiseOutput">-</span>
            </div>
        </div>

        <!-- Paso 3: Bob decapsula -->
        <div class="step-container">
            <div class="step-number">Paso 03</div>
            <div class="step-title">Bob decapsula con su clave privada</div>
            <div class="step-text">
                Bob usa su clave privada para eliminar el ruido del ciphertext y recuperar
                el secreto compartido <span class="highlight">shared_secret_B</span>.
            </div>
            
            <div class="canvas-container">
                <canvas id="lattice3" width="600" height="600"></canvas>
                <div class="slider-container">
                    <label class="slider-label">Nivel de Ruido: <span id="noiseValue">35</span></label>
                    <input type="range" id="noiseSlider" min="0" max="100" value="35" oninput="updateNoise(this.value)">
                </div>
                <div class="controls">
                    <button onclick="cleanNoise()">Limpiar ruido</button>
                    <button onclick="runDecapsulation()">Decapsular</button>
                </div>
                <div class="interactive-label">Empieza con ruido; limpia el ruido para recuperar el secreto</div>
            </div>
            <div class="info-box">
                <strong>Ciphertext recibido (de Alice):</strong> <span id="ciphertextOutputBob">-</span><br>
                <strong>Estado del ruido:</strong> <span id="noiseStatus">Con ruido</span><br>
                <strong>shared_secret_B:</strong> <span id="secretBOutput">-</span>
            </div>
        </div>

        <!-- Paso 4: Verificación -->
        <div class="step-container">
            <div class="step-number">Paso 04</div>
            <div class="step-title">Verificar que ambos secretos coinciden</div>
            <div class="step-text">
                Si Kyber funciona bien, ambos extremos obtienen el mismo secreto compartido.
            </div>
            <div class="info-box">
                <strong>Verificación:</strong> <span id="verifyOutput">-</span>
            </div>
            <div class="controls">
                <button onclick="verifySecrets()">Verificar shared_secret_A == shared_secret_B</button>
            </div>
        </div>

        <!-- Paso 5: AES con el secreto compartido -->
        <div class="step-container">
            <div class="step-number">Paso 05</div>
            <div class="step-title">Usar el secreto como clave AES</div>
            <div class="step-text">
                Si los secretos coinciden, podemos usarlos como clave para cifrar y descifrar un mensaje corto.
            </div>
            <div class="controls">
                <button onclick="runAesDemo()">Cifrar y descifrar "Hello"</button>
            </div>
            <div class="info-box">
                <strong>Clave secreta compartida:</strong> <span id="sharedSecretDisplay">-</span><br>
                <strong>IV:</strong> <span id="aesIvOutput">-</span><br>
                <strong>Ciphertext:</strong> <span id="aesCipherOutput">-</span><br>
                <strong>Mensaje descifrado (usando la clave secreta):</strong> <span id="aesPlainOutput">-</span>
            </div>
        </div>

        <div class="controls footer-controls">
            <button type="button" onclick="window.location.href='index.html#kyber-reticulas-link'">Volver al índice (sección Kyber)</button>
        </div>
    </div>

    <script>
        // Step 2: Random Point Demo
        const canvas2 = document.getElementById('lattice2');
        const ctx2 = canvas2.getContext('2d');
        let randomPoint2 = null;
        let currentVectorCombination = 0;
        let showVectors2 = false;
        let pointIsPublicKey = false;
        let encapsulationNoise = null;
        let encapsulationOffset = null;
        
        function drawLattice2(highlight = false) {
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            const gridSize = 40;
            const offset = 100;
            
            // Draw grid
            ctx2.strokeStyle = 'rgba(42, 63, 95, 0.3)';
            ctx2.lineWidth = 1;
            for (let i = 0; i <= 12; i++) {
                for (let j = 0; j <= 12; j++) {
                    ctx2.fillStyle = '#00f0ff';
                    ctx2.globalAlpha = 0.5;
                    ctx2.beginPath();
                    ctx2.arc(offset + i * gridSize, offset + j * gridSize, 3, 0, Math.PI * 2);
                    ctx2.fill();
                    ctx2.globalAlpha = 1;
                }
            }
            
            if (randomPoint2) {
                // Draw the mystery point
                ctx2.fillStyle = '#ff00aa';
                ctx2.beginPath();
                ctx2.arc(offset + randomPoint2.x * gridSize, offset + randomPoint2.y * gridSize, 10, 0, Math.PI * 2);
                ctx2.fill();
                
                ctx2.strokeStyle = '#ff00aa';
                ctx2.lineWidth = 2;
                ctx2.beginPath();
                ctx2.arc(offset + randomPoint2.x * gridSize, offset + randomPoint2.y * gridSize, 20, 0, Math.PI * 2);
                ctx2.stroke();
                
                if (showVectors2 && !pointIsPublicKey) {
                    // Calculate different vector combinations that reach the same point
                    // For point (x, y), we can represent it as:
                    // Combination 0: x * v1 + y * v2 (standard)
                    // Combination 1: (x + a) * v1 + (y - a) * v2 (where a divides both x and y evenly)
                    // Combination 2: Different basis vectors
                    
                    let displayX, displayY, v1Label, v2Label;
                    
                    if (currentVectorCombination === 0) {
                        // Standard representation
                        displayX = randomPoint2.x;
                        displayY = randomPoint2.y;
                        v1Label = `${displayX} × v₁`;
                        v2Label = `${displayY} × v₂`;
                    } else if (currentVectorCombination === 1) {
                        // Alternative representation using different basis
                        // Show path going vertical first, then horizontal
                        displayX = randomPoint2.y;
                        displayY = randomPoint2.x;
                        v1Label = `${displayY} × v₁`;
                        v2Label = `${displayX} × v₂`;
                        
                        // Draw vertical first
                        ctx2.strokeStyle = '#00f0ff';
                        ctx2.lineWidth = 3;
                        ctx2.setLineDash([5, 5]);
                        
                        ctx2.beginPath();
                        ctx2.moveTo(offset, offset);
                        ctx2.lineTo(offset, offset + displayX * gridSize);
                        ctx2.stroke();
                        
                        ctx2.beginPath();
                        ctx2.moveTo(offset, offset + displayX * gridSize);
                        ctx2.lineTo(offset + displayY * gridSize, offset + randomPoint2.y * gridSize);
                        ctx2.stroke();
                        
                        ctx2.setLineDash([]);
                        
                        ctx2.fillStyle = '#00f0ff';
                        ctx2.font = 'bold 16px Space Mono';
                        ctx2.fillText(`${displayX} × v₂`, offset - 60, offset + (displayX * gridSize) / 2);
                        ctx2.fillText(`${displayY} × v₁`, offset + (displayY * gridSize) / 2 - 30, offset + randomPoint2.y * gridSize + 25);
                        
                        // Add label
                        ctx2.fillStyle = '#ffee00';
                        ctx2.font = 'bold 14px Space Mono';
                        ctx2.fillText('Combinación alternativa: orden diferente', offset + 10, offset + 12 * gridSize + 35);
                        return;
                    } else if (currentVectorCombination === 2) {
                        // Show using scaled vectors
                        const scale = 2;
                        if (randomPoint2.x % scale === 0 && randomPoint2.y % scale === 0) {
                            displayX = randomPoint2.x / scale;
                            displayY = randomPoint2.y / scale;
                            v1Label = `${displayX} × (${scale}v₁)`;
                            v2Label = `${displayY} × (${scale}v₂)`;
                            
                            ctx2.strokeStyle = '#9370db';
                            ctx2.lineWidth = 3;
                            ctx2.setLineDash([5, 5]);
                            
                            // Draw using scaled vectors
                            for (let i = 0; i < displayX; i++) {
                                ctx2.beginPath();
                                ctx2.moveTo(offset + i * scale * gridSize, offset);
                                ctx2.lineTo(offset + (i + 1) * scale * gridSize, offset);
                                ctx2.stroke();
                            }
                            
                            for (let j = 0; j < displayY; j++) {
                                ctx2.beginPath();
                                ctx2.moveTo(offset + randomPoint2.x * gridSize, offset + j * scale * gridSize);
                                ctx2.lineTo(offset + randomPoint2.x * gridSize, offset + (j + 1) * scale * gridSize);
                                ctx2.stroke();
                            }
                            
                            ctx2.setLineDash([]);
                            
                            ctx2.fillStyle = '#9370db';
                            ctx2.font = 'bold 16px Space Mono';
                            ctx2.fillText(v1Label, offset + (randomPoint2.x * gridSize) / 2 - 40, offset - 10);
                            ctx2.fillText(v2Label, offset + randomPoint2.x * gridSize + 10, offset + (randomPoint2.y * gridSize) / 2);
                            
                            ctx2.fillStyle = '#ffee00';
                            ctx2.font = 'bold 14px Space Mono';
                            ctx2.fillText('Combinación con vectores escalados', offset + 10, offset + 12 * gridSize + 35);
                            return;
                        } else {
                            // If point doesn't divide evenly, cycle back to combination 0
                            currentVectorCombination = 0;
                            displayX = randomPoint2.x;
                            displayY = randomPoint2.y;
                            v1Label = `${displayX} × v₁`;
                            v2Label = `${displayY} × v₂`;
                        }
                    }
                    
                    // Draw standard representation (horizontal then vertical)
                    ctx2.strokeStyle = '#ffee00';
                    ctx2.lineWidth = 3;
                    ctx2.setLineDash([5, 5]);
                    
                    ctx2.beginPath();
                    ctx2.moveTo(offset, offset);
                    ctx2.lineTo(offset + randomPoint2.x * gridSize, offset);
                    ctx2.stroke();
                    
                    ctx2.beginPath();
                    ctx2.moveTo(offset + randomPoint2.x * gridSize, offset);
                    ctx2.lineTo(offset + randomPoint2.x * gridSize, offset + randomPoint2.y * gridSize);
                    ctx2.stroke();
                    
                    ctx2.setLineDash([]);
                    
                    ctx2.fillStyle = '#ffee00';
                    ctx2.font = 'bold 16px Space Mono';
                    ctx2.fillText(v1Label, offset + (randomPoint2.x * gridSize) / 2 - 30, offset - 10);
                    ctx2.fillText(v2Label, offset + randomPoint2.x * gridSize + 10, offset + (randomPoint2.y * gridSize) / 2);
                    
                    if (currentVectorCombination === 0) {
                        ctx2.fillStyle = '#ffee00';
                        ctx2.font = 'bold 14px Space Mono';
                        ctx2.fillText('Combinación estándar: horizontal primero', offset + 10, offset + 12 * gridSize + 35);
                    }
                }

                if (pointIsPublicKey && encapsulationOffset) {
                    const pubX = offset + randomPoint2.x * gridSize;
                    const pubY = offset + randomPoint2.y * gridSize;
                    const cipherX = pubX + encapsulationOffset.x;
                    const cipherY = pubY + encapsulationOffset.y;

                    ctx2.strokeStyle = 'rgba(0, 160, 255, 0.7)';
                    ctx2.lineWidth = 2;
                    ctx2.setLineDash([6, 4]);
                    ctx2.beginPath();
                    ctx2.moveTo(pubX, pubY);
                    ctx2.lineTo(cipherX, cipherY);
                    ctx2.stroke();
                    ctx2.setLineDash([]);

                    ctx2.fillStyle = '#00a0ff';
                    ctx2.beginPath();
                    ctx2.arc(cipherX, cipherY, 9, 0, Math.PI * 2);
                    ctx2.fill();

                    ctx2.fillStyle = '#00a0ff';
                    ctx2.font = 'bold 13px Space Mono';
                    ctx2.fillText('Ciphertext', cipherX + 12, cipherY - 10);
                }
            }
        }
        
        function syncPublicKeyToStep2() {
            if (!publicKey5) {
                randomPoint2 = null;
                pointIsPublicKey = false;
                setText('publicKeyOutput', '-');
                drawLattice2();
                return;
            }

            randomPoint2 = {
                x: publicKey5.x / 40,
                y: publicKey5.y / 40
            };
            pointIsPublicKey = true;
            showVectors2 = false;
            currentVectorCombination = 0;
            const latticeX = publicKey5.x / 40;
            const latticeY = publicKey5.y / 40;
            setText('publicKeyOutput', `t = (${latticeX.toFixed(2)}, ${latticeY.toFixed(2)})`);
            drawLattice2();
        }
        
        function revealVectors() {
            if (!randomPoint2) {
                return;
            }
            if (pointIsPublicKey) {
                return;
            }
            showVectors2 = true;
            // Cycle through different combinations
            currentVectorCombination = (currentVectorCombination + 1) % 3;
            drawLattice2();
        }
        
        function resetDemo2() {
            randomPoint2 = null;
            showVectors2 = false;
            currentVectorCombination = 0;
            encapsulationNoise = null;
            encapsulationOffset = null;
            setText('noiseOutput', '-');
            setText('ciphertextOutput', '-');
            setText('secretAOutput', '-');
            syncPublicKeyToStep2();
        }
        
        // Step 3: Noise Visualization
        const canvas3 = document.getElementById('lattice3');
        const ctx3 = canvas3.getContext('2d');
        let noiseLevel = 35;
        
        function drawLattice3(noise) {
            ctx3.clearRect(0, 0, canvas3.width, canvas3.height);
            const gridSize = 40;
            const offset = 100;
            
            // Draw clean lattice points
            for (let i = 0; i <= 12; i++) {
                for (let j = 0; j <= 12; j++) {
                    const cleanX = offset + i * gridSize;
                    const cleanY = offset + j * gridSize;
                    
                    // Add noise
                    const noiseX = (Math.random() - 0.5) * noise * gridSize / 10;
                    const noiseY = (Math.random() - 0.5) * noise * gridSize / 10;
                    
                    // Draw clean point (faded)
                    ctx3.fillStyle = 'rgba(0, 240, 255, 0.3)';
                    ctx3.beginPath();
                    ctx3.arc(cleanX, cleanY, 3, 0, Math.PI * 2);
                    ctx3.fill();
                    
                    // Draw noisy point
                    ctx3.fillStyle = noise > 0 ? '#ff00aa' : '#00f0ff';
                    ctx3.beginPath();
                    ctx3.arc(cleanX + noiseX, cleanY + noiseY, 5, 0, Math.PI * 2);
                    ctx3.fill();
                    
                    // Draw connection if noise is present
                    if (noise > 20) {
                        ctx3.strokeStyle = 'rgba(255, 0, 170, 0.3)';
                        ctx3.lineWidth = 1;
                        ctx3.setLineDash([2, 2]);
                        ctx3.beginPath();
                        ctx3.moveTo(cleanX, cleanY);
                        ctx3.lineTo(cleanX + noiseX, cleanY + noiseY);
                        ctx3.stroke();
                        ctx3.setLineDash([]);
                    }
                }
            }
        }
        
        function setNoiseLevel(value) {
            noiseLevel = parseInt(value);
            document.getElementById('noiseValue').textContent = noiseLevel;
            document.getElementById('noiseSlider').value = noiseLevel;
            drawLattice3(noiseLevel);
            setText('noiseStatus', noiseLevel === 0 ? 'Limpio' : 'Con ruido');
        }

        function updateNoise(value) {
            setNoiseLevel(value);
        }

        function cleanNoise() {
            // Leave a small residual noise to reflect tolerance.
            setNoiseLevel(4);
        }
        
        // Step 5: Key Pair Visualization
        const canvas5 = document.getElementById('lattice5');
        const ctx5 = canvas5.getContext('2d');
        let publicKey5 = null;
        let privateKey5 = null;
        let showPrivate5 = false;
        
        function drawLattice5() {
            ctx5.clearRect(0, 0, canvas5.width, canvas5.height);
            const gridSize = 40;
            const offset = 100;
            
            // Draw lattice
            for (let i = 0; i <= 12; i++) {
                for (let j = 0; j <= 12; j++) {
                    ctx5.fillStyle = 'rgba(0, 240, 255, 0.3)';
                    ctx5.beginPath();
                    ctx5.arc(offset + i * gridSize, offset + j * gridSize, 3, 0, Math.PI * 2);
                    ctx5.fill();
                }
            }
            
            if (publicKey5) {
                if (showPrivate5 && privateKey5) {
                    // FIRST: Draw private key (secret direction) - draw first so it's behind
                    const cleanX = offset + privateKey5.latticeX * gridSize;
                    const cleanY = offset + privateKey5.latticeY * gridSize;
                    
                    // Draw arrow showing direction from origin
                    ctx5.strokeStyle = '#ffee00';
                    ctx5.lineWidth = 4;
                    ctx5.setLineDash([8, 8]);
                    ctx5.beginPath();
                    ctx5.moveTo(offset, offset);
                    ctx5.lineTo(cleanX, cleanY);
                    ctx5.stroke();
                    ctx5.setLineDash([]);
                    
                    // Draw arrowhead
                    const angle = Math.atan2(cleanY - offset, cleanX - offset);
                    ctx5.fillStyle = '#ffee00';
                    ctx5.save();
                    ctx5.translate(cleanX, cleanY);
                    ctx5.rotate(angle);
                    ctx5.beginPath();
                    ctx5.moveTo(0, 0);
                    ctx5.lineTo(-15, -8);
                    ctx5.lineTo(-15, 8);
                    ctx5.closePath();
                    ctx5.fill();
                    ctx5.restore();
                    
                    // Show the clean lattice point (enlarged)
                    ctx5.fillStyle = '#ffee00';
                    ctx5.beginPath();
                    ctx5.arc(cleanX, cleanY, 10, 0, Math.PI * 2);
                    ctx5.fill();
                    
                    // Glow effect for private key
                    ctx5.strokeStyle = 'rgba(255, 238, 0, 0.3)';
                    ctx5.lineWidth = 2;
                    ctx5.beginPath();
                    ctx5.arc(cleanX, cleanY, 20, 0, Math.PI * 2);
                    ctx5.stroke();
                    
                    // Draw the noise vector (from clean point to public key)
                    ctx5.strokeStyle = 'rgba(255, 100, 200, 0.8)';
                    ctx5.lineWidth = 3;
                    ctx5.setLineDash([4, 4]);
                    ctx5.beginPath();
                    ctx5.moveTo(cleanX, cleanY);
                    ctx5.lineTo(offset + publicKey5.x, offset + publicKey5.y);
                    ctx5.stroke();
                    ctx5.setLineDash([]);
                    
                    // Draw small arrowhead for noise
                    const noiseAngle = Math.atan2(offset + publicKey5.y - cleanY, offset + publicKey5.x - cleanX);
                    ctx5.fillStyle = 'rgba(255, 100, 200, 0.8)';
                    ctx5.save();
                    ctx5.translate(offset + publicKey5.x, offset + publicKey5.y);
                    ctx5.rotate(noiseAngle);
                    ctx5.beginPath();
                    ctx5.moveTo(0, 0);
                    ctx5.lineTo(-10, -5);
                    ctx5.lineTo(-10, 5);
                    ctx5.closePath();
                    ctx5.fill();
                    ctx5.restore();
                    
                    // LABELS - positioned to avoid overlap
                    // Origin label
                    ctx5.fillStyle = '#00f0ff';
                    ctx5.font = 'bold 13px Space Mono';
                    ctx5.fillText('Origen', offset - 52, offset + 22);
                    
                    // Private key label - position based on location
                    ctx5.fillStyle = '#ffee00';
                    ctx5.font = 'bold 14px Space Mono';
                    
                    // Position label intelligently based on point location
                    let privLabelX, privLabelY;
                    if (cleanX < 300) {
                        // Point is on left side, put label on right
                        privLabelX = cleanX + 30;
                        privLabelY = cleanY - 40;
                    } else {
                        // Point is on right side, put label on left
                        privLabelX = cleanX - 200;
                        privLabelY = cleanY - 40;
                    }
                    
                    ctx5.fillText('CLAVE PRIVADA', privLabelX, privLabelY);
                    ctx5.font = 'bold 12px Space Mono';
                    ctx5.fillText(`Punto (${privateKey5.latticeX}, ${privateKey5.latticeY})`, privLabelX, privLabelY + 16);
                    
                    // Noise label - in the middle of noise vector
                    const noiseMidX = (cleanX + offset + publicKey5.x) / 2;
                    const noiseMidY = (cleanY + offset + publicKey5.y) / 2;
                    ctx5.fillStyle = 'rgba(255, 100, 200, 1)';
                    ctx5.font = 'bold 12px Space Mono';
                    ctx5.fillText('+ Ruido', noiseMidX + 8, noiseMidY - 12);
                }
                
                // SECOND: Draw public key (on top)
                ctx5.fillStyle = '#ff00aa';
                ctx5.beginPath();
                ctx5.arc(offset + publicKey5.x, offset + publicKey5.y, 10, 0, Math.PI * 2);
                ctx5.fill();
                
                // Glow effect for public key
                ctx5.strokeStyle = 'rgba(255, 0, 170, 0.3)';
                ctx5.lineWidth = 2;
                ctx5.beginPath();
                ctx5.arc(offset + publicKey5.x, offset + publicKey5.y, 20, 0, Math.PI * 2);
                ctx5.stroke();
                
                // Public key label - always visible, positioned to avoid overlap
                ctx5.fillStyle = '#ff00aa';
                ctx5.font = 'bold 14px Space Mono';
                
                // Position based on location
                let pubLabelX, pubLabelY;
                if (offset + publicKey5.x < 300) {
                    pubLabelX = offset + publicKey5.x + 30;
                    pubLabelY = offset + publicKey5.y + 10;
                } else {
                    pubLabelX = offset + publicKey5.x - 200;
                    pubLabelY = offset + publicKey5.y + 10;
                }
                
                ctx5.fillText('CLAVE PÚBLICA', pubLabelX, pubLabelY);
                ctx5.font = 'bold 12px Space Mono';
                ctx5.fillText('(visible para todos)', pubLabelX, pubLabelY + 16);
            }
        }
        
        function generateKeyPair() {
            const gridSize = 40;
            
            // Generate clean lattice point (keep it more centered to avoid going off screen)
            privateKey5 = {
                latticeX: Math.floor(Math.random() * 6) + 4,  // Range: 4-9
                latticeY: Math.floor(Math.random() * 6) + 4   // Range: 4-9
            };
            
            // Add noise to create public key (smaller noise to keep on screen)
            const noiseX = (Math.random() - 0.5) * 25;
            const noiseY = (Math.random() - 0.5) * 25;
            
            publicKey5 = {
                x: privateKey5.latticeX * gridSize + noiseX,
                y: privateKey5.latticeY * gridSize + noiseY
            };
            
            showPrivate5 = false;
            drawLattice5();
            syncPublicKeyToStep2();
        }
        
        function showPrivateKey() {
            if (publicKey5) {
                showPrivate5 = true;
                drawLattice5();
            }
        }
        
        function resetDemo5() {
            publicKey5 = null;
            privateKey5 = null;
            showPrivate5 = false;
            drawLattice5();
            syncPublicKeyToStep2();
        }

        // KEM + AES demo state
        let sharedSecretA = null;
        let sharedSecretB = null;
        let ciphertextBytes = null;

        function bytesToHex(bytes) {
            return Array.from(bytes)
                .map((b) => b.toString(16).padStart(2, '0'))
                .join('');
        }

        function toBase64(bytes) {
            let binary = '';
            bytes.forEach((b) => {
                binary += String.fromCharCode(b);
            });
            return btoa(binary);
        }

        function setText(id, value) {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
            }
        }

        function runEncapsulation() {
            if (!publicKey5) {
                setText('ciphertextOutput', 'Crea la clave pública primero.');
                setText('secretAOutput', '-');
                return;
            }
            sharedSecretA = crypto.getRandomValues(new Uint8Array(16));
            ciphertextBytes = crypto.getRandomValues(new Uint8Array(32));
            sharedSecretB = null;

            setText('ciphertextOutput', bytesToHex(ciphertextBytes));
            setText('ciphertextOutputBob', bytesToHex(ciphertextBytes));
            setText('secretAOutput', bytesToHex(sharedSecretA));
            setText('secretBOutput', '-');
            setText('verifyOutput', '-');
            setText('aesIvOutput', '-');
            setText('aesCipherOutput', '-');
            setText('aesPlainOutput', '-');
            setText('sharedSecretDisplay', '-');
            if (encapsulationNoise !== null) {
                setNoiseLevel(encapsulationNoise);
            } else {
                setNoiseLevel(35);
            }
        }

        function createNoise() {
            if (!publicKey5) {
                setText('noiseOutput', 'Crea la clave pública primero.');
                return;
            }
            encapsulationNoise = Math.floor(Math.random() * 50) + 20;
            const angle = Math.random() * Math.PI * 2;
            const magnitude = 6 + encapsulationNoise * 0.25;
            encapsulationOffset = {
                x: Math.cos(angle) * magnitude,
                y: Math.sin(angle) * magnitude
            };
            setText('noiseOutput', `${encapsulationNoise}`);
            setNoiseLevel(encapsulationNoise);
            drawLattice2();
        }

        function runDecapsulation() {
            if (!sharedSecretA) {
                setText('secretBOutput', 'Encapsula primero.');
                return;
            }

            cleanNoise();
            sharedSecretB = new Uint8Array(sharedSecretA);
            setText('secretBOutput', bytesToHex(sharedSecretB));
            setText('verifyOutput', '-');
        }

        function verifySecrets() {
            if (!sharedSecretA || !sharedSecretB) {
                setText('verifyOutput', 'Faltan secretos para comparar.');
                return;
            }

            const match = bytesToHex(sharedSecretA) === bytesToHex(sharedSecretB);
            setText('verifyOutput', match ? 'Coinciden.' : 'No coinciden.');
        }

        async function runAesDemo() {
            if (!sharedSecretB) {
                setText('aesPlainOutput', 'Decapsula primero.');
                setText('sharedSecretDisplay', '-');
                return;
            }
            if (!crypto.subtle) {
                setText('aesPlainOutput', 'AES requiere un contexto seguro (https o localhost).');
                return;
            }

            const iv = crypto.getRandomValues(new Uint8Array(12));
            const key = await crypto.subtle.importKey(
                'raw',
                sharedSecretB,
                'AES-GCM',
                false,
                ['encrypt', 'decrypt']
            );

            const encoder = new TextEncoder();
            const decoder = new TextDecoder();
            const plaintext = encoder.encode('Hello');
            const ciphertext = new Uint8Array(
                await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plaintext)
            );
            const decrypted = new Uint8Array(
                await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext)
            );

            setText('aesIvOutput', toBase64(iv));
            setText('aesCipherOutput', toBase64(ciphertext));
            setText('aesPlainOutput', decoder.decode(decrypted));
            setText('sharedSecretDisplay', bytesToHex(sharedSecretB));
        }
        
        // Initialize all canvases
        drawLattice2();
        setNoiseLevel(noiseLevel);
        drawLattice5();
    </script>
</body>
</html>
